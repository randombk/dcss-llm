/**
 * IMPORTANT: DO NOT EDIT THIS FILE IN THE crawl/ REPO.
 * EDIT THE VERSION IN THE crawl-patches DIRECTORY INSTEAD.
 * 
 * CHANGES TO THIS FILE IN THE crawl/ REPO WILL BE OVERWRITTEN.
 */

/**
 * @file
 * @brief Functions used to print player related info.
**/

#include "AppHdr.h"

#include "output-llm.h"

#include <cmath>
#include <cstdlib>
#include <sstream>
#include <fstream>

#include "ability.h"
#include "art-enum.h"
#include "areas.h"
#include "branch.h"
#include "colour.h"
#include "describe.h"
#include "english.h"
#include "env.h"
#include "files.h"
#include "god-abil.h"
#include "god-passive.h"
#include "initfile.h"
#include "item-name.h"
#include "item-prop.h"
#include "jobs.h"
#include "lang-fake.h"
#include "libutil.h"
#include "macro.h" // command_to_string
#include "menu.h"
#include "message.h"
#include "misc.h"
#include "mutation.h"
#include "notes.h"
#include "ouch.h"
#include "player-equip.h"
#include "player-stats.h"
#include "prompt.h"
#include "religion.h"
#include "scroller.h"
#include "showsymb.h"
#include "skills.h"
#include "state.h"
#include "status.h"
#include "stringutil.h"
#include "tag-version.h"
#include "terrain.h"
#include "throw.h"
#include "tiles-build-specific.h"
#include "transform.h"
#include "travel.h"
#include "viewchar.h"
#include "view.h"
#include "xom.h"

void output_data_for_llm()
{
    // Open and truncate 'llm_data.log'
    std::ofstream outfile;
    outfile.open("tmp/llm_data.log", std::ofstream::out | std::ofstream::trunc);

    outfile << "Dumping game state" << std::endl;
    outfile << "GAME_SEED: " << you.game_seed << std::endl;

    outfile << std::endl << "===SECTION===" << std::endl; // For easier parsing
    outfile << "PLAYER_LOCATION: " << you.pos().x << "," << you.pos().y << std::endl;
    outfile << "PLAYER_HEALTH: " << you.hp << "/" << you.hp_max << std::endl;
    outfile << "PLAYER_LEVEL: " << you.experience_level << std::endl;
    outfile << "PLAYER_GOLD: " << you.gold << std::endl;
    outfile << "TURN_NUMBER: " << you.num_turns << std::endl;

    // Ignoring these game mechanics for now:
    // - Magic
    // - Regeneration
    // - Gods
    // - Runes
    // - Active Items
    
    // Dump the player's inventory
    outfile << std::endl << "===SECTION===" << std::endl; // For easier parsing
    outfile << "PLAYER_INVENTORY" << std::endl;
    for (int i = 0; i < ENDOFPACK; i++)
    {
        const item_def& item = you.inv[i];
        if (!item.defined()) continue;

        outfile << "ITEM: " << item.name(DESC_PLAIN) << std::endl;
    }

    outfile << std::endl << "===SECTION===" << std::endl; // For easier parsing
    outfile << "PLAYER_EQUIP" << std::endl;
    for (const player_equip_entry& entry : you.equipment.items)
    {
        const item_def& item = entry.get_item();
        outfile << "ITEM: " << item.name(DESC_PLAIN) << std::endl;
    }

    // Dump the current floor map - both actual and remembered
    outfile << std::endl << "===SECTION===" << std::endl; // For easier parsing
    outfile << "CURRENT_FLOOR_MAP" << std::endl;
    for (int y = 0; y < GYM; y++)
    {
        for (int x = 0; x < GXM; x++)
        {
            const coord_def pos(x, y);
            const dungeon_feature_type pos_actual = env.grid(pos);
            
            // Skip empty cells
            if (pos_actual == DNGN_UNSEEN) continue;

            const map_cell pos_memory = env.map_knowledge(pos);
            const monster* mon = monster_at(pos);

            outfile << "CELL: " << x << "," << y << ": " << dungeon_feature_name(pos_actual);

            if (feat_is_traversable(pos_actual))
            {
                outfile << "[PATH]";
            }

            if (pos_memory.feat() != DNGN_UNSEEN)
            {
                // To simplify things, let memory be the same as the actual tile
                // outfile << " || " << dungeon_feature_name(pos_memory.feat());
                outfile << "[KNOWN]";
            }
            outfile << std::endl;


            if (mon)
            {
                outfile << "MONSTER: " << x << "," << y << ": " << mon->name(DESC_PLAIN) << std::endl;
            }

            if (pos_memory.item())
            {
                const item_def& item = *pos_memory.item();
                outfile << "ITEM: " << x << "," << y << ": " << item.name(DESC_INVENTORY) << std::endl;
            }
        }
    }    

    outfile.close();
}
